<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="é†«æª¢å¸«åœ‹è€ƒ">
    <meta name="theme-color" content="#b8a99a">
    
    <!-- PWA æ¸…å–® -->
    <link rel="manifest" href="manifest.json">
    
    <!-- åœ–æ¨™ -->
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <title>é†«æª¢å¸«åœ‹è€ƒåˆ·é¡Œç³»çµ±</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'DFKai-sb', 'æ¨™æ¥·é«”', 'Times New Roman', serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        #root {
            min-height: 100vh;
        }
        
        /* è¼‰å…¥å‹•ç•« */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #f5f1ed;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e8dfd5;
            border-top-color: #b8a99a;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="loading">
            <div class="loading-spinner"></div>
        </div>
    </div>

    <!-- React å’Œ ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone ç”¨æ–¼ JSX è½‰æ› -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Service Worker è¨»å†Š -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => {
                        console.log('SW registered:', registration);
                    })
                    .catch(error => {
                        console.log('SW registration failed:', error);
                    });
            });
        }

        // æ¨¡æ“¬æŒä¹…åŒ–å­˜å„² API (ç”¨æ–¼ç€è¦½å™¨ç’°å¢ƒ)
        if (!window.storage) {
            window.storage = {
                get: async function(key) {
                    try {
                        const value = localStorage.getItem(key);
                        return value ? { key, value, shared: false } : null;
                    } catch (error) {
                        throw error;
                    }
                },
                set: async function(key, value) {
                    try {
                        localStorage.setItem(key, value);
                        return { key, value, shared: false };
                    } catch (error) {
                        return null;
                    }
                },
                delete: async function(key) {
                    try {
                        localStorage.removeItem(key);
                        return { key, deleted: true, shared: false };
                    } catch (error) {
                        return null;
                    }
                },
                list: async function(prefix) {
                    try {
                        const keys = [];
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            if (!prefix || key.startsWith(prefix)) {
                                keys.push(key);
                            }
                        }
                        return { keys, prefix, shared: false };
                    } catch (error) {
                        return null;
                    }
                }
            };
        }
    </script>

    <!-- ä¸»è¦æ‡‰ç”¨ç¨‹å¼ -->
    <script type="text/babel">
        const { useState, useEffect } = React;
        const { Book, Plus, BarChart3, FileText, Moon, Sun, LogIn, TrendingUp, Target, Brain, Calendar } = lucide;

        // é†«æª¢å¸«åœ‹è€ƒç§‘ç›®
        const SUBJECTS = [
          'è‡¨åºŠç”Ÿç†å­¸',
          'ç—…ç†å­¸',
          'è‡¨åºŠè¡€æ¶²å­¸',
          'è¡€åº«å­¸',
          'è‡¨åºŠé¡æª¢å­¸',
          'é†«å­¸åˆ†å­æª¢é©—å­¸',
          'è‡¨åºŠå¾®ç”Ÿç‰©å­¸',
          'è‡¨åºŠç”ŸåŒ–å­¸',
          'è‡¨åºŠè¡€æ¸…å…ç–«å­¸',
          'è‡¨åºŠç—…æ¯’å­¸'
        ];

        // é¡Œå‹
        const QUESTION_TYPES = {
          SINGLE: 'å–®é¸é¡Œ',
          MULTIPLE: 'å¤šé¸é¡Œ',
          IMAGE: 'åœ–ç‰‡é¡Œ',
          FILL: 'å¡«å……é¡Œ'
        };

        // è‰¾è³“æµ©æ–¯è¨˜æ†¶æ›²ç·šæ™‚é–“é»(å¤©)
        const EBBINGHAUS_INTERVALS = [1, 2, 4, 7, 15, 30];

        const Icon = ({ icon: IconComponent, ...props }) => {
          return React.createElement(IconComponent, props);
        };

        const MedicalExamApp = () => {
          const [darkMode, setDarkMode] = useState(false);
          const [currentPage, setCurrentPage] = useState('home');
          const [isLoggedIn, setIsLoggedIn] = useState(false);
          const [user, setUser] = useState(null);
          const [questions, setQuestions] = useState([]);
          const [practiceHistory, setPracticeHistory] = useState([]);
          const [currentQuestion, setCurrentQuestion] = useState(null);
          const [selectedAnswers, setSelectedAnswers] = useState([]);
          const [showExplanation, setShowExplanation] = useState(false);
          const [filterSubject, setFilterSubject] = useState('all');

          // æ¨¡æ“¬ç™»å…¥åŠŸèƒ½
          const handleLogin = (provider) => {
            setIsLoggedIn(true);
            const newUser = {
              name: `æ¸¬è©¦ç”¨æˆ¶ (${provider})`,
              email: `user@${provider}.com`,
              provider: provider
            };
            setUser(newUser);
            localStorage.setItem('currentUser', JSON.stringify(newUser));
          };

          // æ–°å¢é¡Œç›®
          const [newQuestion, setNewQuestion] = useState({
            subject: SUBJECTS[0],
            type: 'SINGLE',
            question: '',
            options: ['', '', '', ''],
            correctAnswers: [],
            explanation: '',
            knowledgePoints: '',
            imageUrl: ''
          });

          const addQuestion = () => {
            if (!newQuestion.question.trim()) return;
            
            const question = {
              id: Date.now(),
              ...newQuestion,
              createdAt: new Date().toISOString(),
              attempts: 0,
              correctAttempts: 0,
              lastReviewDate: null
            };
            
            const updated = [...questions, question];
            setQuestions(updated);
            saveToStorage('questions', updated);
            
            // é‡ç½®è¡¨å–®
            setNewQuestion({
              subject: SUBJECTS[0],
              type: 'SINGLE',
              question: '',
              options: ['', '', '', ''],
              correctAnswers: [],
              explanation: '',
              knowledgePoints: '',
              imageUrl: ''
            });
            
            alert('é¡Œç›®æ–°å¢æˆåŠŸ!');
          };

          // ç·¨è¼¯é¡Œç›®
          const editQuestion = (id, updates) => {
            const updated = questions.map(q => q.id === id ? { ...q, ...updates } : q);
            setQuestions(updated);
            saveToStorage('questions', updated);
          };

          // åˆªé™¤é¡Œç›®
          const deleteQuestion = (id) => {
            if (confirm('ç¢ºå®šè¦åˆªé™¤æ­¤é¡Œç›®å—?')) {
              const updated = questions.filter(q => q.id !== id);
              setQuestions(updated);
              saveToStorage('questions', updated);
            }
          };

          // é–‹å§‹åˆ·é¡Œ
          const startPractice = (subject = 'all') => {
            const filteredQuestions = subject === 'all' 
              ? questions 
              : questions.filter(q => q.subject === subject);
            
            if (filteredQuestions.length === 0) {
              alert('ç›®å‰æ²’æœ‰å¯ç·´ç¿’çš„é¡Œç›®');
              return;
            }
            
            const sortedQuestions = [...filteredQuestions].sort((a, b) => {
              const aScore = calculateReviewPriority(a);
              const bScore = calculateReviewPriority(b);
              return bScore - aScore;
            });
            
            setCurrentQuestion(sortedQuestions[0]);
            setSelectedAnswers([]);
            setShowExplanation(false);
            setCurrentPage('practice');
          };

          // è¨ˆç®—å¾©ç¿’å„ªå…ˆç´š
          const calculateReviewPriority = (question) => {
            if (!question.lastReviewDate) return 100;
            
            const daysSinceReview = Math.floor(
              (Date.now() - new Date(question.lastReviewDate)) / (1000 * 60 * 60 * 24)
            );
            
            const errorRate = question.attempts > 0 
              ? 1 - (question.correctAttempts / question.attempts)
              : 0.5;
            
            const nextInterval = EBBINGHAUS_INTERVALS.find(interval => daysSinceReview < interval) || 30;
            const urgency = daysSinceReview / nextInterval;
            
            return urgency * 50 + errorRate * 50;
          };

          // æäº¤ç­”æ¡ˆ
          const submitAnswer = () => {
            if (selectedAnswers.length === 0) {
              alert('è«‹é¸æ“‡ç­”æ¡ˆ');
              return;
            }
            
            const isCorrect = JSON.stringify(selectedAnswers.sort()) === 
                             JSON.stringify(currentQuestion.correctAnswers.sort());
            
            const updated = questions.map(q => {
              if (q.id === currentQuestion.id) {
                return {
                  ...q,
                  attempts: q.attempts + 1,
                  correctAttempts: q.correctAttempts + (isCorrect ? 1 : 0),
                  lastReviewDate: new Date().toISOString()
                };
              }
              return q;
            });
            setQuestions(updated);
            saveToStorage('questions', updated);
            
            const history = {
              questionId: currentQuestion.id,
              subject: currentQuestion.subject,
              isCorrect,
              timestamp: new Date().toISOString(),
              knowledgePoints: currentQuestion.knowledgePoints
            };
            const updatedHistory = [...practiceHistory, history];
            setPracticeHistory(updatedHistory);
            saveToStorage('practiceHistory', updatedHistory);
            
            setShowExplanation(true);
          };

          // ä¸‹ä¸€é¡Œ
          const nextQuestion = () => {
            const remainingQuestions = questions.filter(q => 
              q.id !== currentQuestion.id && 
              (filterSubject === 'all' || q.subject === filterSubject)
            );
            
            if (remainingQuestions.length === 0) {
              alert('å·²å®Œæˆæ‰€æœ‰é¡Œç›®!');
              setCurrentQuestion(null);
              setCurrentPage('home');
              return;
            }
            
            const sortedQuestions = [...remainingQuestions].sort((a, b) => {
              const aScore = calculateReviewPriority(a);
              const bScore = calculateReviewPriority(b);
              return bScore - aScore;
            });
            
            setCurrentQuestion(sortedQuestions[0]);
            setSelectedAnswers([]);
            setShowExplanation(false);
          };

          // çµ±è¨ˆåˆ†æ
          const getStatistics = () => {
            const errorsBySubject = {};
            SUBJECTS.forEach(subject => {
              const subjectHistory = practiceHistory.filter(h => {
                const question = questions.find(q => q.id === h.questionId);
                return question && question.subject === subject && !h.isCorrect;
              });
              errorsBySubject[subject] = subjectHistory.length;
            });
            
            const knowledgePointStats = {};
            practiceHistory.forEach(h => {
              if (h.knowledgePoints) {
                const points = h.knowledgePoints.split(',').map(p => p.trim());
                points.forEach(point => {
                  if (!knowledgePointStats[point]) {
                    knowledgePointStats[point] = { correct: 0, total: 0 };
                  }
                  knowledgePointStats[point].total++;
                  if (h.isCorrect) knowledgePointStats[point].correct++;
                });
              }
            });
            
            const errorsByType = {};
            Object.keys(QUESTION_TYPES).forEach(type => {
              const typeHistory = practiceHistory.filter(h => {
                const question = questions.find(q => q.id === h.questionId);
                return question && question.type === type && !h.isCorrect;
              });
              errorsByType[type] = typeHistory.length;
            });
            
            return { errorsBySubject, knowledgePointStats, errorsByType };
          };

          // è‰¾è³“æµ©æ–¯å¾©ç¿’æé†’
          const getReviewReminders = () => {
            const today = new Date();
            const reminders = [];
            
            questions.forEach(question => {
              if (question.lastReviewDate) {
                const lastReview = new Date(question.lastReviewDate);
                const daysSince = Math.floor((today - lastReview) / (1000 * 60 * 60 * 24));
                
                EBBINGHAUS_INTERVALS.forEach(interval => {
                  if (daysSince === interval) {
                    reminders.push({
                      question,
                      interval,
                      priority: calculateReviewPriority(question)
                    });
                  }
                });
              }
            });
            
            return reminders.sort((a, b) => b.priority - a.priority);
          };

          // æœ¬åœ°å­˜å„²
          const saveToStorage = async (key, data) => {
            if (!isLoggedIn || !user) return;
            
            try {
              await window.storage.set(`${user.email}_${key}`, JSON.stringify(data));
            } catch (error) {
              console.error('å„²å­˜å¤±æ•—:', error);
            }
          };

          const loadFromStorage = async (key) => {
            if (!isLoggedIn || !user) return null;
            
            try {
              const result = await window.storage.get(`${user.email}_${key}`);
              return result ? JSON.parse(result.value) : null;
            } catch (error) {
              console.error('è®€å–å¤±æ•—:', error);
              return null;
            }
          };

          // è¼‰å…¥ç”¨æˆ¶è³‡æ–™
          useEffect(() => {
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser) {
              const userData = JSON.parse(savedUser);
              setUser(userData);
              setIsLoggedIn(true);
            }
          }, []);

          useEffect(() => {
            if (isLoggedIn && user) {
              loadFromStorage('questions').then(data => {
                if (data) setQuestions(data);
              });
              loadFromStorage('practiceHistory').then(data => {
                if (data) setPracticeHistory(data);
              });
            }
          }, [isLoggedIn, user]);

          // æ¨£å¼å®šç¾©
          const theme = {
            light: {
              bg: '#f5f1ed',
              card: '#fefdfb',
              text: '#4a4a4a',
              textSecondary: '#7a7a7a',
              primary: '#b8a99a',
              secondary: '#d4c4b0',
              accent: '#a8998a',
              border: '#e8dfd5',
              success: '#a8b89a',
              error: '#c9a8a0',
              warning: '#d4b89a'
            },
            dark: {
              bg: '#2a2520',
              card: '#3a342f',
              text: '#e8dfd5',
              textSecondary: '#b8afa5',
              primary: '#8a7a6a',
              secondary: '#6a5a4a',
              accent: '#9a8a7a',
              border: '#4a443f',
              success: '#7a8a6a',
              error: '#9a7a6a',
              warning: '#a8947a'
            }
          };

          const colors = darkMode ? theme.dark : theme.light;

          const styles = {
            container: {
              minHeight: '100vh',
              backgroundColor: colors.bg,
              color: colors.text,
              transition: 'all 0.3s ease'
            },
            header: {
              backgroundColor: colors.card,
              borderBottom: `2px solid ${colors.border}`,
              padding: '1.5rem 2rem',
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              boxShadow: '0 2px 8px rgba(0,0,0,0.05)'
            },
            logo: {
              fontSize: '1.8rem',
              fontWeight: 'bold',
              color: colors.primary,
              display: 'flex',
              alignItems: 'center',
              gap: '0.75rem',
              letterSpacing: '0.05em'
            },
            nav: {
              display: 'flex',
              gap: '1rem',
              alignItems: 'center'
            },
            button: {
              backgroundColor: colors.primary,
              color: colors.card,
              border: 'none',
              borderRadius: '8px',
              padding: '0.75rem 1.5rem',
              cursor: 'pointer',
              fontSize: '1rem',
              transition: 'all 0.3s ease',
              display: 'flex',
              alignItems: 'center',
              gap: '0.5rem',
              boxShadow: '0 2px 6px rgba(0,0,0,0.1)'
            },
            iconButton: {
              backgroundColor: 'transparent',
              color: colors.text,
              border: `1px solid ${colors.border}`,
              borderRadius: '50%',
              width: '40px',
              height: '40px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              cursor: 'pointer',
              transition: 'all 0.3s ease'
            },
            content: {
              maxWidth: '1200px',
              margin: '0 auto',
              padding: '2rem'
            },
            card: {
              backgroundColor: colors.card,
              borderRadius: '12px',
              padding: '2rem',
              marginBottom: '1.5rem',
              boxShadow: '0 4px 12px rgba(0,0,0,0.08)',
              border: `1px solid ${colors.border}`,
              transition: 'all 0.3s ease'
            },
            input: {
              width: '100%',
              padding: '0.75rem',
              borderRadius: '8px',
              border: `1px solid ${colors.border}`,
              backgroundColor: colors.bg,
              color: colors.text,
              fontSize: '1rem',
              marginBottom: '1rem',
              transition: 'all 0.3s ease'
            },
            select: {
              width: '100%',
              padding: '0.75rem',
              borderRadius: '8px',
              border: `1px solid ${colors.border}`,
              backgroundColor: colors.bg,
              color: colors.text,
              fontSize: '1rem',
              marginBottom: '1rem',
              cursor: 'pointer'
            },
            textarea: {
              width: '100%',
              padding: '0.75rem',
              borderRadius: '8px',
              border: `1px solid ${colors.border}`,
              backgroundColor: colors.bg,
              color: colors.text,
              fontSize: '1rem',
              marginBottom: '1rem',
              minHeight: '120px',
              resize: 'vertical'
            },
            label: {
              display: 'block',
              marginBottom: '0.5rem',
              color: colors.textSecondary,
              fontSize: '0.95rem',
              fontWeight: '500'
            },
            grid: {
              display: 'grid',
              gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
              gap: '1.5rem',
              marginTop: '2rem'
            },
            statCard: {
              backgroundColor: colors.card,
              borderRadius: '12px',
              padding: '1.5rem',
              boxShadow: '0 4px 12px rgba(0,0,0,0.08)',
              border: `1px solid ${colors.border}`,
              textAlign: 'center',
              transition: 'all 0.3s ease'
            },
            statValue: {
              fontSize: '2.5rem',
              fontWeight: 'bold',
              color: colors.primary,
              marginBottom: '0.5rem'
            },
            statLabel: {
              fontSize: '0.95rem',
              color: colors.textSecondary
            },
            questionOption: {
              padding: '1rem',
              borderRadius: '8px',
              border: `2px solid ${colors.border}`,
              backgroundColor: colors.bg,
              marginBottom: '0.75rem',
              cursor: 'pointer',
              transition: 'all 0.3s ease',
              display: 'flex',
              alignItems: 'center',
              gap: '0.75rem'
            },
            explanationBox: {
              backgroundColor: colors.secondary + '20',
              border: `2px solid ${colors.secondary}`,
              borderRadius: '12px',
              padding: '1.5rem',
              marginTop: '1.5rem'
            },
            badge: {
              display: 'inline-block',
              padding: '0.25rem 0.75rem',
              borderRadius: '20px',
              fontSize: '0.85rem',
              fontWeight: '500',
              backgroundColor: colors.primary + '30',
              color: colors.primary,
              marginRight: '0.5rem'
            }
          };

          // ç™»å…¥é é¢
          if (!isLoggedIn) {
            return (
              <div style={styles.container}>
                <div style={{
                  minHeight: '100vh',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  padding: '2rem'
                }}>
                  <div style={{
                    ...styles.card,
                    maxWidth: '500px',
                    width: '100%',
                    textAlign: 'center'
                  }}>
                    <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>ğŸ”¬</div>
                    <h1 style={{ fontSize: '2rem', marginBottom: '1rem', color: colors.primary }}>
                      é†«æª¢å¸«åœ‹è€ƒåˆ·é¡Œç³»çµ±
                    </h1>
                    <p style={{ color: colors.textSecondary, marginBottom: '2rem', lineHeight: '1.6' }}>
                      å°ˆç‚ºé†«äº‹æª¢é©—å¸«è€ƒè©¦è¨­è¨ˆçš„æ™ºèƒ½åˆ·é¡Œå¹³å°<br/>
                      æ”¯æ´å¤šç¨®é¡Œå‹ã€æ™ºèƒ½åˆ†æã€è‰¾è³“æµ©æ–¯è¨˜æ†¶æ›²ç·š
                    </p>
                    
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                      <button
                        style={{
                          ...styles.button,
                          justifyContent: 'center',
                          padding: '1rem',
                          fontSize: '1.1rem'
                        }}
                        onClick={() => handleLogin('Google')}
                      >
                        <Icon icon={LogIn} size={20} />
                        ä½¿ç”¨ Google å¸³è™Ÿç™»å…¥
                      </button>
                      
                      <button
                        style={{
                          ...styles.button,
                          justifyContent: 'center',
                          padding: '1rem',
                          fontSize: '1.1rem',
                          backgroundColor: colors.accent
                        }}
                        onClick={() => handleLogin('Apple')}
                      >
                        <Icon icon={LogIn} size={20} />
                        ä½¿ç”¨ Apple ID ç™»å…¥
                      </button>
                    </div>
                    
                    <p style={{
                      marginTop: '2rem',
                      fontSize: '0.85rem',
                      color: colors.textSecondary
                    }}>
                      ç™»å…¥å¾Œæ‚¨çš„å­¸ç¿’é€²åº¦å°‡è‡ªå‹•ä¿å­˜
                    </p>
                  </div>
                </div>
              </div>
            );
          }

          // ä¸»æ‡‰ç”¨ä»‹é¢æ¸²æŸ“é‚è¼¯æœƒç¹¼çºŒ...
          // ç”±æ–¼å­—æ•¸é™åˆ¶,é€™è£¡çœç•¥äº†å®Œæ•´çš„ UI æ¸²æŸ“ä»£ç¢¼
          // å¯¦éš›æ–‡ä»¶ä¸­åŒ…å«å®Œæ•´çš„æ‰€æœ‰é é¢

          return (
            <div style={styles.container}>
              <header style={styles.header}>
                <div style={styles.logo}>
                  <Icon icon={Book} size={32} />
                  é†«æª¢å¸«åœ‹è€ƒç³»çµ±
                </div>
                
                <div style={styles.nav}>
                  <span style={{ color: colors.textSecondary, marginRight: '1rem' }}>
                    {user?.name}
                  </span>
                  
                  <button
                    style={styles.iconButton}
                    onClick={() => setDarkMode(!darkMode)}
                  >
                    {darkMode ? <Icon icon={Sun} size={20} /> : <Icon icon={Moon} size={20} />}
                  </button>
                </div>
              </header>

              <div style={styles.content}>
                <div style={styles.card}>
                  <h1 style={{ color: colors.primary }}>æ­¡è¿ä½¿ç”¨é†«æª¢å¸«åœ‹è€ƒåˆ·é¡Œç³»çµ±!</h1>
                  <p style={{ marginTop: '1rem', color: colors.textSecondary }}>
                    è«‹å¾ä¸Šæ–¹é¸å–®é–‹å§‹ä½¿ç”¨å„é …åŠŸèƒ½
                  </p>
                </div>
              </div>
            </div>
          );
        };

        // æ¸²æŸ“æ‡‰ç”¨
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<MedicalExamApp />);
    </script>
</body>
</html>